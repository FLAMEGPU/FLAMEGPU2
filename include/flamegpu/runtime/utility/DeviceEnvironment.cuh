#ifndef INCLUDE_FLAMEGPU_RUNTIME_UTILITY_DEVICEENVIRONMENT_CUH_
#define INCLUDE_FLAMEGPU_RUNTIME_UTILITY_DEVICEENVIRONMENT_CUH_

// #include <cuda_runtime.h>
#include <string>
#include <cassert>

#include "flamegpu/runtime/utility/DeviceMacroProperty.cuh"
#include "flamegpu/util/type_decode.h"

namespace flamegpu {

/**
 * Utility for accessing environmental properties
 * These can only be read within agent functions
 * They can be set and updated within host functions
 */
class ReadOnlyDeviceEnvironment {
    /**
     * Constructs the object
     */
    friend class ReadOnlyDeviceAPI;
    /**
     * Performs runtime validation that CURVE_NAMESPACE_HASH matches host value
     */
    friend class EnvironmentManager;
    friend class CUDAMacroEnvironment;

 protected:
    /**
     * Device accessible copy of curve namespace hash, this is precomputed from EnvironmentManager::CURVE_NAMESPACE_HASH
     * EnvironmentManager::initialiseDevice() validates that this value matches
     */
    __host__ __device__ static constexpr unsigned int CURVE_NAMESPACE_HASH() { return 0X1428F902u; }
    /**
     * Device accessible copy of macro namespace hash, this is precomputed from CUDAMacroEnvironment::MACRO_NAMESPACE_HASH
     * CUDAMacroEnvironment::CUDAMacroEnvironment() validates that this value matches
     */
    __host__ __device__ static constexpr unsigned int MACRO_NAMESPACE_HASH() { return 0xF3ABEB4F; }
    /**
     * Hash of the model's name, this is added to CURVE_NAMESPACE_HASH and variable name hash to find curve hash
     */
    const detail::curve::Curve::NamespaceHash &modelname_hash;
    /**
     * Constructor, requires the model name hash to init modelname_hash
     * @param _modelname_hash Hash of model name generated by curveGetVariableHash()
     */
    __device__ __forceinline__ ReadOnlyDeviceEnvironment(const detail::curve::Curve::NamespaceHash &_modelname_hash)
        : modelname_hash(_modelname_hash) { }

 public:
    /**
     * Gets an environment property
     * @param name name used for accessing the property, this value should be a string literal e.g. "foobar"
     * @tparam T Type of the environment property being accessed
     * @tparam N Length of property name, this should always be implicit if passing a string literal
     * @throws exception::DeviceError If name is not a valid property within the environment (flamegpu must be built with SEATBELTS enabled for device error checking)
     * @throws exception::DeviceError If T is not the type of the environment property specified by name (flamegpu must be built with SEATBELTS enabled for device error checking)
     */
    template<typename T, unsigned int N>
    __device__ __forceinline__ T getProperty(const char(&name)[N]) const;
    /**
     * Gets an element of an environment property array
     * @param name name used for accessing the property, this value should be a string literal e.g. "foobar"
     * @param index Index of the element within the environment property array to return
     * @tparam T Type of the environment property being accessed
     * @tparam N Length of property name, this should always be implicit if passing a string literal
     * @throws exception::DeviceError If name is not a valid property within the environment (flamegpu must be built with SEATBELTS enabled for device error checking)
     * @throws exception::DeviceError If T is not the type of the environment property specified by name (flamegpu must be built with SEATBELTS enabled for device error checking)
     * @throws exception::DeviceError If index is out of bounds for the environment property array specified by name (flamegpu must be built with SEATBELTS enabled for device error checking)
     */
    template<typename T, unsigned int N>
    __device__ __forceinline__ T getProperty(const char(&name)[N], const unsigned int&index) const;
    /**
     * Returns whether the named env property exists
     * @param name name used for accessing the property, this value should be a string literal e.g. "foobar"
     * @tparam N Length of variable name, this should always be implicit if passing a string literal
     * @note Use of this function is not recommended as it should be unnecessary and will impact performance
     */
    template<unsigned int N>
    __device__ __forceinline__ bool containsProperty(const char(&name)[N]) const;
    /**
     * Returns a read-only accessor to the named macro property
     * @param name name used for accessing the property, this value should be a string literal e.g. "foobar"
     * @tparam I Length of macro property in the 1st dimension, default 1
     * @tparam J Length of macro property in the 2nd dimension, default 1
     * @tparam K Length of macro property in the 3rd dimension, default 1
     * @tparam W Length of macro property in the 4th dimension, default 1
     * @tparam N Length of variable name, this should always be implicit if passing a string literal
     */
    template<typename T, unsigned int I = 1, unsigned int J = 1, unsigned int K = 1, unsigned int W = 1, unsigned int N>
    __device__ __forceinline__ ReadOnlyDeviceMacroProperty<T, I, J, K, W> getMacroProperty(const char(&name)[N]) const;
};
/**
 * Utility for accessing environmental properties
 * These can only be read within agent functions
 * They can be set and updated within host functions
 * This version also allows limited write access to device macro properties
 */
class DeviceEnvironment : public ReadOnlyDeviceEnvironment {
 public:
    /**
     * Constructor, requires the model name hash to init modelname_hash
     * @param _modelname_hash Hash of model name generated by curveGetVariableHash()
     * @note Public because it's constructed by a templated class
     */
    __device__ __forceinline__ DeviceEnvironment(const detail::curve::Curve::NamespaceHash& _modelname_hash)
        : ReadOnlyDeviceEnvironment(_modelname_hash) { }
    /**
     * Returns a read-only accessor to the named macro property
     * @param name name used for accessing the property, this value should be a string literal e.g. "foobar"
     * @tparam I Length of macro property in the 1st dimension, default 1
     * @tparam J Length of macro property in the 2nd dimension, default 1
     * @tparam K Length of macro property in the 3rd dimension, default 1
     * @tparam W Length of macro property in the 4th dimension, default 1
     * @tparam N Length of variable name, this should always be implicit if passing a string literal
     */
    template<typename T, unsigned int I = 1, unsigned int J = 1, unsigned int K = 1, unsigned int W = 1, unsigned int N>
    __device__ __forceinline__ DeviceMacroProperty<T, I, J, K, W> getMacroProperty(const char(&name)[N]) const;
};

// Mash compilation of these functions from RTC builds as this requires a dynamic implementation of the function in curve_rtc
#ifndef __CUDACC_RTC__
/**
 * Getters
 */
template<typename T, unsigned int N>
__device__ __forceinline__ T ReadOnlyDeviceEnvironment::getProperty(const char(&name)[N]) const {
    extern __shared__ const detail::curve::Curve::CurveTable* buff[];
    detail::curve::Curve::VariableHash cvh = CURVE_NAMESPACE_HASH() + modelname_hash + detail::curve::Curve::variableHash(name);
    const auto cv = detail::curve::Curve::getVariable(cvh);
#if !defined(SEATBELTS) || SEATBELTS
    if (cv ==  detail::curve::Curve::UNKNOWN_VARIABLE) {
        DTHROW("Environment property with name: %s was not found.\n", name);
    } else if (buff[0]->sizes[cv] * buff[0]->lengths[cv] != type_decode<T>::len_t * sizeof(typename type_decode<T>::type_t)) {
        DTHROW("Environment property with name: %s type size mismatch %llu != %llu.\n", name, buff[0]->sizes[cv], sizeof(T));
    } else {
        return *reinterpret_cast<const T*>(reinterpret_cast<const char*>(buff[1]) + reinterpret_cast<ptrdiff_t>(buff[0]->variables[cv]));
    }
    return {};
#else
    return *reinterpret_cast<const T*>(reinterpret_cast<const char*>(buff[1]) + reinterpret_cast<ptrdiff_t>(buff[0]->variables[cv]));
#endif
}
template<typename T, unsigned int N>
__device__ __forceinline__ T ReadOnlyDeviceEnvironment::getProperty(const char(&name)[N], const unsigned int &index) const {
    extern __shared__ const detail::curve::Curve::CurveTable* buff[];
    detail::curve::Curve::VariableHash cvh = CURVE_NAMESPACE_HASH() + modelname_hash + detail::curve::Curve::variableHash(name);
    const auto cv = detail::curve::Curve::getVariable(cvh);
#if !defined(SEATBELTS) || SEATBELTS
    const unsigned int t_index = type_decode<T>::len_t * index + type_decode<T>::len_t;
    if (cv ==  detail::curve::Curve::UNKNOWN_VARIABLE) {
        DTHROW("Environment property array with name: %s was not found.\n", name);
    } else if (buff[0]->sizes[cv] != sizeof(typename type_decode<T>::type_t)) {
        DTHROW("Environment property array with name: %s type size mismatch %llu != %llu.\n", name, buff[0]->sizes[cv], sizeof(T));
    } else if (buff[0]->lengths[cv] < t_index || t_index < index) {
        DTHROW("Environment property array with name: %s index %u is out of bounds (length %u).\n", name, index, buff[0]->lengths[cv]);
    } else {
        return *(reinterpret_cast<const T*>(reinterpret_cast<const char*>(buff[1]) + reinterpret_cast<ptrdiff_t>(buff[0]->variables[cv])) + index);
    }
    return {};
#else
    return *(reinterpret_cast<const T*>(reinterpret_cast<const char*>(buff[1]) + reinterpret_cast<ptrdiff_t>(buff[0]->variables[cv])) + index);
#endif
}

/**
 * Util
 */
template<unsigned int N>
__device__ __forceinline__ bool ReadOnlyDeviceEnvironment::containsProperty(const char(&name)[N]) const {
    detail::curve::Curve::VariableHash cvh = CURVE_NAMESPACE_HASH() + modelname_hash + detail::curve::Curve::variableHash(name);
    return detail::curve::Curve::getVariable(cvh) != detail::curve::Curve::UNKNOWN_VARIABLE;
}

template<typename T, unsigned int I, unsigned int J, unsigned int K, unsigned int W, unsigned int N>
__device__ __forceinline__ ReadOnlyDeviceMacroProperty<T, I, J, K, W> ReadOnlyDeviceEnvironment::getMacroProperty(const char(&name)[N]) const {
    extern __shared__ const detail::curve::Curve::CurveTable* buff[];
    detail::curve::Curve::VariableHash cvh = MACRO_NAMESPACE_HASH() + modelname_hash + detail::curve::Curve::variableHash(name);
    const auto cv = detail::curve::Curve::getVariable(cvh);
#if !defined(SEATBELTS) || SEATBELTS
    if (cv == detail::curve::Curve::UNKNOWN_VARIABLE) {
        DTHROW("Environment macro property name: %s was not found.\n", name);
    } else if (buff[0]->sizes[cv] != sizeof(T)) {
        DTHROW("Environment macro property with name: %s type size mismatch %llu != %llu.\n", name, buff[0]->sizes[cv], sizeof(T));
    } else if (buff[0]->lengths[cv] != I * J * K * W) {
        DTHROW("Environment macro property with name: %s total length mismatch (%u != %u).\n", name, buff[0]->lengths[cv], I * J * K * W);
    } else {
        return DeviceMacroProperty<T, I, J, K, W>(reinterpret_cast<T*>(buff[0]->variables[cv]),
        reinterpret_cast<unsigned int*>(buff[0]->variables[cv] + (I * J * K * W * sizeof(T))));  // Read-write flag resides in 8 bits at the end of the buffer
    }
    return ReadOnlyDeviceMacroProperty<T, I, J, K, W>(nullptr, nullptr);
#else
    return ReadOnlyDeviceMacroProperty<T, I, J, K, W>(reinterpret_cast<T*>(buff[0]->variables[cv]));
#endif
}
template<typename T, unsigned int I, unsigned int J, unsigned int K, unsigned int W, unsigned int N>
__device__ __forceinline__ DeviceMacroProperty<T, I, J, K, W> DeviceEnvironment::getMacroProperty(const char(&name)[N]) const {
    extern __shared__ const detail::curve::Curve::CurveTable* buff[];
    detail::curve::Curve::VariableHash cvh = MACRO_NAMESPACE_HASH() + modelname_hash + detail::curve::Curve::variableHash(name);
    const auto cv = detail::curve::Curve::getVariable(cvh);
#if !defined(SEATBELTS) || SEATBELTS
    if (cv == detail::curve::Curve::UNKNOWN_VARIABLE) {
        DTHROW("Environment macro property name: %s was not found.\n", name);
    } else if (buff[0]->sizes[cv] != sizeof(T)) {
        DTHROW("Environment macro property with name: %s type size mismatch %llu != %llu.\n", name, buff[0]->sizes[cv], sizeof(T));
    } else if (buff[0]->lengths[cv] != I * J * K * W) {
        DTHROW("Environment macro property with name: %s total length mismatch (%u != %u).\n", name, buff[0]->lengths[cv], I * J * K * W);
    } else {
        return DeviceMacroProperty<T, I, J, K, W>(reinterpret_cast<T*>(buff[0]->variables[cv]),
            reinterpret_cast<unsigned int*>(buff[0]->variables[cv] + (I * J * K * W * sizeof(T))));  // Read-write flag resides in 8 bits at the end of the buffer
    }
    return DeviceMacroProperty<T, I, J, K, W>(nullptr, nullptr);
#else
    return DeviceMacroProperty<T, I, J, K, W>(reinterpret_cast<T*>(buff[0]->variables[cv]));
#endif
}
#endif  // __CUDACC_RTC__

}  // namespace flamegpu

#endif  // INCLUDE_FLAMEGPU_RUNTIME_UTILITY_DEVICEENVIRONMENT_CUH_
