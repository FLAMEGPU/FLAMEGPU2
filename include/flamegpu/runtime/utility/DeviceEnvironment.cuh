#ifndef INCLUDE_FLAMEGPU_RUNTIME_UTILITY_DEVICEENVIRONMENT_CUH_
#define INCLUDE_FLAMEGPU_RUNTIME_UTILITY_DEVICEENVIRONMENT_CUH_

// #include <cuda_runtime.h>
#include <cstdint>
#include <string>
#include <cassert>

namespace flamegpu {

#ifndef __CUDACC_RTC__
namespace detail {
    /**
     * Defined in EnvironmentManager.cu
     */
    extern __constant__ char c_envPropBuffer[EnvironmentManager::MAX_BUFFER_SIZE];
}  // namespace detail
#endif

/**
 * Utility for accessing environmental properties
 * These can only be read within agent functions
 * They can be set and updated within host functions
 */
class DeviceEnvironment {
    /**
     * Constructs the object
     */
    friend class ReadOnlyDeviceAPI;
    /**
     * Performs runtime validation that CURVE_NAMESPACE_HASH matches host value
     */
    friend class EnvironmentManager;
    /**
     * Device accessible copy of curve namespace hash, this is precomputed from EnvironmentManager::CURVE_NAMESPACE_HASH
     * EnvironmentManager::EnvironmentManager() validates that this value matches
     */
    __host__ __device__ static constexpr unsigned int CURVE_NAMESPACE_HASH() { return 0X1428F902u; }
    /**
     * Hash of the model's name, this is added to CURVE_NAMESPACE_HASH and variable name hash to find curve hash
     */
    const detail::curve::Curve::NamespaceHash &modelname_hash;
    /**
     * Constructor, requires the model name hash to init modelname_hash
     * @param _modelname_hash Hash of model name generated by curveGetVariableHash()
     */
    __device__ __forceinline__ DeviceEnvironment(const detail::curve::Curve::NamespaceHash &_modelname_hash)
        : modelname_hash(_modelname_hash) { }

 public:
    /**
     * Gets an environment property
     * @param name name used for accessing the property, this value should be a string literal e.g. "foobar"
     * @tparam T Type of the environment property being accessed
     * @tparam N Length of property name, this should always be implicit if passing a string literal
     * @throws exception::DeviceError If name is not a valid property within the environment (flamegpu must be built with SEATBELTS enabled for device error checking)
     * @throws exception::DeviceError If T is not the type of the environment property specified by name (flamegpu must be built with SEATBELTS enabled for device error checking)
     */
    template<typename T, unsigned int N>
    __device__ __forceinline__ T getProperty(const char(&name)[N]) const;
    /**
     * Gets an element of an environment property array
     * @param name name used for accessing the property, this value should be a string literal e.g. "foobar"
     * @param index Index of the element within the environment property array to return
     * @tparam T Type of the environment property being accessed
     * @tparam N Length of property name, this should always be implicit if passing a string literal
     * @throws exception::DeviceError If name is not a valid property within the environment (flamegpu must be built with SEATBELTS enabled for device error checking)
     * @throws exception::DeviceError If T is not the type of the environment property specified by name (flamegpu must be built with SEATBELTS enabled for device error checking)
     * @throws exception::DeviceError If index is out of bounds for the environment property array specified by name (flamegpu must be built with SEATBELTS enabled for device error checking)
     */
    template<typename T, unsigned int N>
    __device__ __forceinline__ T getProperty(const char(&name)[N], const unsigned int&index) const;
    /**
     * Returns whether the named env property exists
     * @param name name used for accessing the property, this value should be a string literal e.g. "foobar"
     * @tparam N Length of variable name, this should always be implicit if passing a string literal
     * @note Use of this function is not recommended as it should be unnecessary and will impact performance
     */
    template<unsigned int N>
    __device__ __forceinline__ bool containsProperty(const char(&name)[N]) const;
};

// Mash compilation of these functions from RTC builds as this requires a dynamic implementation of the function in curve_rtc
#ifndef __CUDACC_RTC__
/**
 * Getters
 */
template<typename T, unsigned int N>
__device__ __forceinline__ T DeviceEnvironment::getProperty(const char(&name)[N]) const {
    detail::curve::Curve::VariableHash cvh = CURVE_NAMESPACE_HASH() + modelname_hash + detail::curve::Curve::variableHash(name);
    const auto cv = detail::curve::Curve::getVariable(cvh);
#if !defined(SEATBELTS) || SEATBELTS
    if (cv ==  detail::curve::Curve::UNKNOWN_VARIABLE) {
        DTHROW("Environment property with name: %s was not found.\n", name);
#if defined(USE_GLM)
    } else if (detail::curve::detail::d_sizes[cv] * detail::curve::detail::d_lengths[cv] != sizeof(T)) {
        DTHROW("Environment property with name: %s type size mismatch %llu != %llu.\n", name, detail::curve::detail::d_sizes[cv] * detail::curve::detail::d_lengths[cv], sizeof(T));
#else
    } else if (detail::curve::detail::d_sizes[cv] != sizeof(T)) {
        DTHROW("Environment property with name: %s type size mismatch %llu != %llu.\n", name, detail::curve::detail::d_sizes[cv], sizeof(T));
#endif
    } else {
        return *reinterpret_cast<T*>(detail::c_envPropBuffer + reinterpret_cast<ptrdiff_t>(detail::curve::detail::d_variables[cv]));
    }
    return {};
#else
    return *reinterpret_cast<T*>(detail::c_envPropBuffer + reinterpret_cast<ptrdiff_t>(detail::curve::detail::d_variables[cv]));
#endif
}
template<typename T, unsigned int N>
__device__ __forceinline__ T DeviceEnvironment::getProperty(const char(&name)[N], const unsigned int &index) const {
    detail::curve::Curve::VariableHash cvh = CURVE_NAMESPACE_HASH() + modelname_hash + detail::curve::Curve::variableHash(name);
    const auto cv = detail::curve::Curve::getVariable(cvh);
#if !defined(SEATBELTS) || SEATBELTS
    if (cv ==  detail::curve::Curve::UNKNOWN_VARIABLE) {
        DTHROW("Environment property array with name: %s was not found.\n", name);
    } else if (detail::curve::detail::d_sizes[cv] != sizeof(T)) {
        DTHROW("Environment property array with name: %s type size mismatch %llu != %llu.\n", name, detail::curve::detail::d_sizes[cv], sizeof(T));
    } else if (detail::curve::detail::d_lengths[cv] <= index) {
        DTHROW("Environment property array with name: %s index %u is out of bounds (length %u).\n", name, index, detail::curve::detail::d_lengths[cv]);
    } else {
        return *(reinterpret_cast<T*>(detail::c_envPropBuffer + reinterpret_cast<ptrdiff_t>(detail::curve::detail::d_variables[cv])) + index);
    }
    return {};
#else
    return *(reinterpret_cast<T*>(detail::c_envPropBuffer + reinterpret_cast<ptrdiff_t>(detail::curve::detail::d_variables[cv])) + index);
#endif
}

/**
 * Util
 */
template<unsigned int N>
__device__ __forceinline__ bool DeviceEnvironment::containsProperty(const char(&name)[N]) const {
    detail::curve::Curve::VariableHash cvh = CURVE_NAMESPACE_HASH() + modelname_hash + detail::curve::Curve::variableHash(name);
    return detail::curve::Curve::getVariable(cvh) != detail::curve::Curve::UNKNOWN_VARIABLE;
}

#endif  // __CUDACC_RTC__

}  // namespace flamegpu

#endif  // INCLUDE_FLAMEGPU_RUNTIME_UTILITY_DEVICEENVIRONMENT_CUH_
