# Minimum CMake version 3.18 for CUDA --std=c++17
# for multi-config generators, CMake must be >= 3.20 for python bindings due to use of generator expressions in outputs/byproducts
cmake_minimum_required(VERSION 3.18...3.25 FATAL_ERROR)

# Defines multiple CMake targets and custom commands to build swig bindings, create a python wheel and (optionally) install it into a venv.
# defines `pyflamegpu` - the user-facing target which creates the wheel.
# It depends on `pyflamegpu_swig` which performs the expensive swig phase (i.e. pyflamepgu.dll/so/pyd).

# Define a few advanced options which are only relevant to this file
# By default, build into a venv, otherwise it is set to ON anyway. 
option(FLAMEGPU_BUILD_PYTHON_VENV "Enable the use of a venv for swig/python installation" ON)
mark_as_advanced(FLAMEGPU_BUILD_PYTHON_VENV)
# Add option to embed the cuda version in the python local version, for pseudo downstream releases / to differentiate wheel files.
option(FLAMEGPU_BUILD_PYTHON_LOCALVERSION "Embed CUDA version for the build in the local information" ON)
mark_as_advanced(FLAMEGPU_BUILD_PYTHON_LOCALVERSION)

# Get the root of the repository to find other CMake files etc.
get_filename_component(FLAMEGPU_ROOT ${CMAKE_CURRENT_SOURCE_DIR}/../../ REALPATH)

# Ensure that the cuda toolkit package is available
find_package(CUDAToolkit REQUIRED)

# include CMake function to enable setting of warning suppressions
include(${FLAMEGPU_ROOT}/cmake/warnings.cmake)
# Get FLAMEGPU Version information
include(${FLAMEGPU_ROOT}/cmake/version.cmake)

# Python module name (must match module name in swig input *.i file), leading to import <x>
SET(PYTHON_MODULE_NAME pyflamegpu)
# Set the python distribution name, which in practice should probably always match the module name to avoid metadata issues and duplicate installs of the same module.
set(PYTHON_DISTRIBUTION_NAME ${PYTHON_MODULE_NAME})

# Set the swig cmake target name (i.e. this needs to not be pyflamegpu)
set(PYTHON_SWIG_TARGET_NAME "${PYTHON_MODULE_NAME}_swig")

# Set the python module target name (i.e. what users should use)
set(PYTHON_MODULE_TARGET_NAME "${PYTHON_MODULE_NAME}")

message(STATUS "-----Configuring Project: ${PYTHON_MODULE_TARGET_NAME}-----")

# Output the configured name/version for the python module to stdout
if(FLAMEGPU_VERSION_PYTHON_PUBLIC AND FLAMEGPU_VERSION_PYTHON_LOCAL)
  message(STATUS "${PYTHON_DISTRIBUTION_NAME}-${FLAMEGPU_VERSION_PYTHON_PUBLIC} (${FLAMEGPU_VERSION_PYTHON_LOCAL})")
endif()

# Set the output directory where the wheel etc should be placed.
# CMAKE 3.20 is required for byproducts contianing $<CONFIG> (i.e. multiconfig generators.) Workaround by only setting if supported, or usiing CMAKE_BUILD_TYPE for non-multi-generators.
# This is required for msvc multi-generator usage. For older cmake and non-mulit-config generators CMAKE_BUILD_TYPE can be used instead.
SET(PYTHON_LIB_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib/$<CONFIG>/python)
get_property(isMultiConfig GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if("${CMAKE_VERSION}" VERSION_LESS "3.20")
  if(NOT ${isMultiConfig})
    # Non-multi-config generators can use CMAKE_BINARY_DIR with CMake <= 3.20 (i.e make supports 3.18+)
    SET(PYTHON_LIB_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib/${CMAKE_BUILD_TYPE}/python)
  else()
    # Multiconfig generators (msvc) do not support genex in byproducts/outptus, but these are required.
    message(FATAL_ERROR "CMake >= 3.20 is required for ${PYTHON_MODULE_NAME} when using a multi-config generator such as '${CMAKE_GENERATOR}'. Please upgrade your CMake, or use a single-config geneator if possible.")
  endif()
endif()
unset(isMultiConfig)
# Python library temp directory (for autogenerated swig files etc.)
SET(PYTHON_LIB_TEMP_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})

# set input file name
SET(SWIG_INPUT_FILE_NAME flamegpu)

#########################################
## Swig input processing and building  ##
#########################################

# setup properties of swig input file as required
set_property(SOURCE ${SWIG_INPUT_FILE_NAME}.i PROPERTY CPLUSPLUS ON)
set_property(SOURCE ${SWIG_INPUT_FILE_NAME}.i PROPERTY SWIG_MODULE_NAME ${PYTHON_MODULE_NAME})
set_property(SOURCE ${SWIG_INPUT_FILE_NAME}.i PROPERTY SWIG_FLAGS "-threads")
# Get the list of FLAMEGPU2 headers from the flamegpu target
get_target_property(FLAMEGPU_HEADERS flamegpu SOURCES)
list(FILTER FLAMEGPU_HEADERS INCLUDE REGEX ".*\.(h|hpp|cuh)$")
# Specify the dependency for swig file processing on all known headers manually.
set_property(SOURCE ${SWIG_INPUT_FILE_NAME}.i PROPERTY DEPENDS ${FLAMEGPU_HEADERS})
unset (FLAMEGPU_HEADERS)
# Add swig module via the native CMake integration integraiton.
swig_add_library(${PYTHON_SWIG_TARGET_NAME}
	TYPE SHARED
	LANGUAGE python
	OUTPUT_DIR ${PYTHON_LIB_TEMP_DIRECTORY}/${PYTHON_MODULE_NAME}
	SOURCES ${SWIG_INPUT_FILE_NAME}.i
  )

# Set the OUTPUT_NAME property on the swig target, so it can be different to the target name (i.e. so the final target is name pyflamegpu, the swig target is named somethign else, but the module is named pyflamegpu. Requires CMake >= 3.15.
set_property(TARGET ${PYTHON_SWIG_TARGET_NAME} PROPERTY OUTPUT_NAME ${PYTHON_MODULE_NAME})

# configure wrapper code to build with cuda compiler
set_source_files_properties(${PYTHON_LIB_TEMP_DIRECTORY}/${PYTHON_MODULE_NAME}/${SWIG_INPUT_FILE_NAME}PYTHON_wrap.cxx PROPERTIES LANGUAGE CUDA)

# use the target include directories
set_property(TARGET ${PYTHON_SWIG_TARGET_NAME} PROPERTY SWIG_USE_TARGET_INCLUDE_DIRECTORIES ON)

# needs to have RDC enable for the project
set_property(TARGET ${PYTHON_SWIG_TARGET_NAME} PROPERTY CUDA_SEPARABLE_COMPILATION ON)

# Build with the SWIG pre-processor macro enabled
set_property(TARGET ${PYTHON_SWIG_TARGET_NAME} APPEND PROPERTY SWIG_GENERATED_COMPILE_DEFINITIONS "SWIG")

# Require C++17 as a public target property for C++ and CUDA, with no extensions, and the standard is required
target_compile_features(${PYTHON_SWIG_TARGET_NAME} PUBLIC cxx_std_17)
target_compile_features(${PYTHON_SWIG_TARGET_NAME} PUBLIC cuda_std_17)
set_property(TARGET ${PYTHON_SWIG_TARGET_NAME} PROPERTY CXX_EXTENSIONS OFF)
set_property(TARGET ${PYTHON_SWIG_TARGET_NAME} PROPERTY CUDA_EXTENSIONS OFF)
set_property(TARGET ${PYTHON_SWIG_TARGET_NAME} PROPERTY CXX_STANDARD_REQUIRED ON)
set_property(TARGET ${PYTHON_SWIG_TARGET_NAME} PROPERTY CUDA_STANDARD_REQUIRED ON)

# Disable all compiler warnings, as we do not control the generated code
flamegpu_disable_compiler_warnings(TARGET "${PYTHON_SWIG_TARGET_NAME}")

# Suppress additional warnings
flamegpu_suppress_some_compiler_warnings(TARGET "${PYTHON_SWIG_TARGET_NAME}")

# Set bigobj property for windows compiler, required by the very large generated swig file
if(MSVC)
  target_compile_options(${PYTHON_SWIG_TARGET_NAME} PRIVATE "$<$<COMPILE_LANGUAGE:CUDA>:SHELL:-Xcompiler /bigobj>")
endif()

# set include directories for module build
target_include_directories(${PYTHON_SWIG_TARGET_NAME} PRIVATE ${Python3_INCLUDE_DIRS})

# Get the list of compile definitions from the FLAMEGPU target, and also set them for swig generation and swig compilation
# This removes duplciation of setting FLAMEGPU compiler definitions
get_target_property(flamegpu_compile_defines flamegpu COMPILE_DEFINITIONS)
foreach(flamegpu_definition ${flamegpu_compile_defines})
  set_property(TARGET ${PYTHON_SWIG_TARGET_NAME} APPEND PROPERTY SWIG_COMPILE_DEFINITIONS "${flamegpu_definition}")
  set_property(TARGET ${PYTHON_SWIG_TARGET_NAME} APPEND PROPERTY SWIG_GENERATED_COMPILE_DEFINITIONS "${flamegpu_definition}")
endforeach()
unset(flamegpu_compile_defines)

# link with the static flamegpu, inherriting links on nvrtc and the cuda driver api etc
target_link_libraries(${PYTHON_SWIG_TARGET_NAME} PRIVATE flamegpu)

# Requires the development module.
target_link_libraries(${PYTHON_SWIG_TARGET_NAME} PRIVATE Python3::Module)

#######################
## Python Packaging  ##
#######################
# Once the swig target has been compiled, producing the python library as required, it needs to be packaged with additional python files etc.
# First, create mutated copies of certain files during cmake configuration, which requires some pre-processing to correctly set contents.
# Then, define a custom target with the user-invoked name, which depends on the copeid fiels + swig generated python module + other python targets to build the wheel. Optionally(?) installs into a venv for user-testing.


# ---------------
# Configure files for python packaging
# ---------------

# List non swig python source file for code generator module that should be packaged
set(PYTHON_CODEGEN_SRC_FILES
  ${CMAKE_CURRENT_SOURCE_DIR}/codegen/__init__.py
  ${CMAKE_CURRENT_SOURCE_DIR}/codegen/codegen.py
)

# cleanup the flamegpu include file paths, so they're relative (begin `include/`) and separated by `", "`
foreach(FLAMEGPU_INC_FILE IN LISTS FLAMEGPU_INCLUDE)
  file(RELATIVE_PATH FLAMEGPU_INC_FILE_CLEAN "${FLAMEGPU_ROOT}" "${FLAMEGPU_INC_FILE}")
  set(FLAMEGPU_INCLUDE_CLEAN "${FLAMEGPU_INCLUDE_CLEAN}'${FLAMEGPU_INC_FILE_CLEAN}', ")
  unset(FLAMEGPU_INC_FILE_CLEAN)
endforeach()

# cleanup code generator module files, so they're separated by `", "` (file list is already using relative paths)
foreach(PYTHON_CODEGEN_FILE IN LISTS PYTHON_CODEGEN_SRC_FILES)
  file(RELATIVE_PATH PYTHON_CODEGEN_FILE_CLEAN "${CMAKE_CURRENT_SOURCE_DIR}" "${PYTHON_CODEGEN_FILE}")
  set(FLAMEGPU_CODEGEN_INCLUDE_CLEAN "${FLAMEGPU_CODEGEN_INCLUDE_CLEAN}'${FPYTHON_CODEGEN_FILE_CLEAN}', ")
  unset(PYTHON_CODEGEN_FILE_CLEAN)
endforeach()

# Locate and cleanup GLM include files, so they're separated by `", "`
if(FLAMEGPU_ENABLE_GLM)
    FetchContent_GetProperties(glm POPULATED glm_POPULATED SOURCE_DIR glm_SOURCE_DIR)
    if (glm_POPULATED)
        # Locate the root header to find the header directory
        find_path(glm_ROOT
        NAMES
            glm/glm.hpp
        PATHS
            ${glm_SOURCE_DIR}
        NO_CACHE
        )
        # Build a list of all files in include dir
        FILE(GLOB_RECURSE glm_INC_FILES "${glm_ROOT}glm/*")
        # Add license to that list
        list(APPEND glm_INC_FILES "${glm_ROOT}copying.txt")
        # Clean, add separator and setup file copy
        unset(glm_POPULATED)
        unset(glm_SOURCE_DIR)
        foreach(glm_INC_FILE IN LISTS glm_INC_FILES)
          file(RELATIVE_PATH glm_INC_FILE_CLEAN "${glm_ROOT}" "${glm_INC_FILE}")
          set(GLM_INCLUDE_CLEAN "${GLM_INCLUDE_CLEAN}'glm/${glm_INC_FILE_CLEAN}', ") # This var is used by setup.py template
        endforeach()
    else()
        message(FATAL_ERROR "Python cmake can't find glm")
    endif()
endif()

# Build a list of OS specific python package_data entries.
set(FLAMEGPU_PYTHON_PACKAGE_DATA_OS_SPECIFIC "")
if (FLAMEGPU_VISUALISATION)
  if(COMMAND flamegpu_visualiser_get_runtime_depenencies)
    flamegpu_visualiser_get_runtime_depenencies(vis_runtime_dependencies)
    foreach(vis_runtime_dependency ${vis_runtime_dependencies})
      # get the filename from teh abs filepath
      get_filename_component(vis_runtime_dependency_fname ${vis_runtime_dependency} NAME)
      list(APPEND FLAMEGPU_PYTHON_PACKAGE_DATA_OS_SPECIFIC "'${vis_runtime_dependency_fname}'")
      unset(vis_runtime_dependency_fname)
    endforeach()
    unset(vis_runtime_dependencies)
  endif()
endif()
# Join the cmake list with commas to form the value for conf.py
if(FLAMEGPU_PYTHON_PACKAGE_DATA_OS_SPECIFIC)
  string (REPLACE ";" ", " FLAMEGPU_PYTHON_PACKAGE_DATA_OS_SPECIFIC "${FLAMEGPU_PYTHON_PACKAGE_DATA_OS_SPECIFIC}")
endif()


# configure the python setup.py and __init__.py files for packaging and output to the final lib output folder. Must configure into a temp dir then call file(GENERATE) due to use of generator expression in PYTHON_LIB_OUTPUT_DIRECTORY
configure_file(
	${CMAKE_CURRENT_SOURCE_DIR}/setup.py.in
	${PYTHON_LIB_TEMP_DIRECTORY}/setup.py.in
	@ONLY)
file(GENERATE
	OUTPUT ${PYTHON_LIB_OUTPUT_DIRECTORY}/setup.py
	INPUT ${PYTHON_LIB_TEMP_DIRECTORY}/setup.py.in)
unset(FLAMEGPU_PYTHON_PACKAGE_DATA_OS_SPECIFIC)
configure_file(
	${CMAKE_CURRENT_SOURCE_DIR}/__init__.py.in
	${PYTHON_LIB_TEMP_DIRECTORY}/__init__.py.in
	@ONLY)
file(GENERATE
	OUTPUT ${PYTHON_LIB_OUTPUT_DIRECTORY}/src/${PYTHON_MODULE_NAME}/__init__.py
	INPUT ${PYTHON_LIB_TEMP_DIRECTORY}/__init__.py.in)

# Function to find if python module MODULE_NAME is available, and error if it is not available.
function(flamegpu_search_python_module MODULE_NAME)
  execute_process(
    COMMAND ${Python3_EXECUTABLE} -c "import ${MODULE_NAME}; print(${MODULE_NAME}.__version__) if hasattr(${MODULE_NAME}, '__version__') else print('Unknown');"
    RESULT_VARIABLE _RESULT
    OUTPUT_VARIABLE MODULE_VERSION
    ERROR_QUIET
    OUTPUT_STRIP_TRAILING_WHITESPACE
    )
  if(${_RESULT} STREQUAL "0")
    message(STATUS "Found python module: ${MODULE_NAME} (version \"${MODULE_VERSION}\")")
  else()
    message(FATAL_ERROR 
      "  Unable to find required python module \"${MODULE_NAME}\".\n"
      "  Please install this to your python environment, e.g.\n"
      "    python3 -m pip install ${MODULE_NAME}")
  endif()
endfunction()

# Look for required python modules to build the python module, error if they are not found.
flamegpu_search_python_module(setuptools)
flamegpu_search_python_module(wheel)
flamegpu_search_python_module(build)

## ------
# Define custom commands to produce files in the current cmake directory, a custom target which the user invokes to build the python wheel with appropriate dependencies configured, and any post-build steps required.
## ------
set(PYTHON_FLAMEGPU_LIB_OUTPUT_MODULE_DIR "${PYTHON_LIB_OUTPUT_DIRECTORY}/src/${PYTHON_MODULE_NAME}")
# Only expliclty create the directory under linux, msbuild emits warnings and is fine without.
if(NOT WIN32)
  add_custom_command(
    OUTPUT "${PYTHON_FLAMEGPU_LIB_OUTPUT_MODULE_DIR}/include"
    COMMAND ${CMAKE_COMMAND} -E make_directory "${PYTHON_FLAMEGPU_LIB_OUTPUT_MODULE_DIR}/include"
  )
  list(APPEND PYTHON_MODULE_TARGET_NAME_DEPENDS "${PYTHON_FLAMEGPU_LIB_OUTPUT_MODULE_DIR}/include")
endif()
# Build a list of include files at their required locations, and the custom command used to create them individually. Does not use configure_file as occurs at build time not configure time (i.e. only if pyflamegpu is built)
foreach(FLAMEGPU_INC_FILE IN LISTS FLAMEGPU_INCLUDE)
  file(RELATIVE_PATH FLAMEGPU_INC_FILE_CLEAN "${FLAMEGPU_ROOT}" "${FLAMEGPU_INC_FILE}")
  set(PYTHON_FLAMEGPU_LIB_OUTPUT_INC_FILE "${PYTHON_FLAMEGPU_LIB_OUTPUT_MODULE_DIR}/${FLAMEGPU_INC_FILE_CLEAN}")
  add_custom_command(
    OUTPUT "${PYTHON_FLAMEGPU_LIB_OUTPUT_INC_FILE}"
    DEPENDS ${FLAMEGPU_INC_FILE}
    COMMAND ${CMAKE_COMMAND} -E copy_if_different ${FLAMEGPU_INC_FILE} ${PYTHON_FLAMEGPU_LIB_OUTPUT_INC_FILE}
    # COMMENT "Copying ${FLAMEGPU_INC_FILE} to ${PYTHON_FLAMEGPU_LIB_OUTPUT_INC_FILE}"
  )
  list(APPEND PYTHON_MODULE_TARGET_NAME_DEPENDS "${PYTHON_FLAMEGPU_LIB_OUTPUT_INC_FILE}")
  unset(PYTHON_FLAMEGPU_LIB_OUTPUT_INC_FILE)
endforeach()

# Create the codegen directory, and copy the codegen files in.
# Only explicitly create the directory under linux, msbuild emits warnings and is fine without.
if(NOT WIN32)
  add_custom_command(
    OUTPUT "${PYTHON_FLAMEGPU_LIB_OUTPUT_MODULE_DIR}/codegen"
    COMMAND ${CMAKE_COMMAND} -E make_directory "${PYTHON_FLAMEGPU_LIB_OUTPUT_MODULE_DIR}/codegen"
  )
  list(APPEND PYTHON_MODULE_TARGET_NAME_DEPENDS "${PYTHON_FLAMEGPU_LIB_OUTPUT_MODULE_DIR}/codegen")
endif()

# Copy each codegen file into the python module directory, and append the filename to the list of python wheel dependencies.
foreach(PYTHON_CODEGEN_FILE IN LISTS PYTHON_CODEGEN_SRC_FILES)
  file(RELATIVE_PATH PYTHON_CODEGEN_FILE_CLEAN "${CMAKE_CURRENT_SOURCE_DIR}" "${PYTHON_CODEGEN_FILE}")
  set(PYTHON_FLAMEGPU_LIB_OUTPUT_CODEGEN_FILE "${PYTHON_FLAMEGPU_LIB_OUTPUT_MODULE_DIR}/${PYTHON_CODEGEN_FILE_CLEAN}")
  add_custom_command(
    OUTPUT "${PYTHON_FLAMEGPU_LIB_OUTPUT_CODEGEN_FILE}"
    DEPENDS ${PYTHON_CODEGEN_FILE}
    COMMAND ${CMAKE_COMMAND} -E copy_if_different ${PYTHON_CODEGEN_FILE} ${PYTHON_FLAMEGPU_LIB_OUTPUT_CODEGEN_FILE}
    COMMENT "Copying ${PYTHON_CODEGEN_FILE} to ${PYTHON_FLAMEGPU_LIB_OUTPUT_CODEGEN_FILE}"
  )
  list(APPEND PYTHON_MODULE_TARGET_NAME_DEPENDS "${PYTHON_FLAMEGPU_LIB_OUTPUT_CODEGEN_FILE}")
  unset(PYTHON_FLAMEGPU_LIB_OUTPUT_CODEGEN_FILE)
endforeach()

# Copy GLM files into the python module directory and append the filename to the list of python wheel dependencies.
if(FLAMEGPU_ENABLE_GLM)
    foreach(glm_INC_FILE IN LISTS glm_INC_FILES)
      file(RELATIVE_PATH glm_INC_FILE_CLEAN "${glm_ROOT}" "${glm_INC_FILE}")
      set(PYTHON_FLAMEGPU_LIB_OUTPUT_glm_FILE "${PYTHON_FLAMEGPU_LIB_OUTPUT_MODULE_DIR}/glm/${glm_INC_FILE_CLEAN}")
      add_custom_command(
        OUTPUT "${PYTHON_FLAMEGPU_LIB_OUTPUT_glm_FILE}"
        DEPENDS ${glm_INC_FILE}
        COMMAND ${CMAKE_COMMAND} -E copy_if_different ${glm_INC_FILE} ${PYTHON_FLAMEGPU_LIB_OUTPUT_glm_FILE}
        COMMENT "Copying ${glm_INC_FILE} to ${PYTHON_FLAMEGPU_LIB_OUTPUT_glm_FILE}"
      )
      list(APPEND PYTHON_MODULE_TARGET_NAME_DEPENDS "${PYTHON_FLAMEGPU_LIB_OUTPUT_glm_FILE}")
      unset(PYTHON_FLAMEGPU_LIB_OUTPUT_glm_FILE)
    endforeach()
    unset(glm_ROOT)
    unset(glm_INC_FILES)
endif()

# Copy the visualisation dlls if required, this must occur before the wheel is built
if (FLAMEGPU_VISUALISATION)
  if(COMMAND flamegpu_visualiser_get_runtime_depenencies)
    flamegpu_visualiser_get_runtime_depenencies(vis_runtime_dependencies)
    foreach(vis_runtime_dependency ${vis_runtime_dependencies})
      # get the filename from teh abs filepath
      get_filename_component(vis_runtime_dependency_fname ${vis_runtime_dependency} NAME)
      set(vis_runtime_dependency_dest "${PYTHON_FLAMEGPU_LIB_OUTPUT_MODULE_DIR}/${vis_runtime_dependency_fname}")
      add_custom_command(
        OUTPUT ${vis_runtime_dependency_dest}
        DEPENDS ${vis_runtime_dependency}
        COMMAND ${CMAKE_COMMAND} -E copy_if_different ${vis_runtime_dependency} ${vis_runtime_dependency_dest}
        COMMENT "Copying ${vis_runtime_dependency_fname} to ${vis_runtime_dependency_dest}"
      )
      # Add the file to the list of dependencies for the python module target
      list(APPEND PYTHON_MODULE_TARGET_NAME_DEPENDS "${vis_runtime_dependency_dest}")
      unset(vis_runtime_dependency_fname)
      unset(vis_runtime_dependency_dest)
    endforeach()
    unset(vis_runtime_dependencies)
  endif()
endif()

# Define a custom commmand to copy the swig generated .py file to the correct destination for wheel generation. This output is then appended to the list of dependencies for the target which builds the wheel.
set(PYTHON_FLAMEGPU_LIB_OUTPUT_MODULE_PY "${PYTHON_LIB_OUTPUT_DIRECTORY}/src/${PYTHON_MODULE_NAME}/${PYTHON_MODULE_NAME}.py")
set(PYTHON_FLAMEGPU_TEMP_MODULE_PY ${PYTHON_LIB_TEMP_DIRECTORY}/${PYTHON_MODULE_NAME}/${PYTHON_MODULE_NAME}.py)
add_custom_command(
  OUTPUT ${PYTHON_FLAMEGPU_LIB_OUTPUT_MODULE_PY}
  DEPENDS ${PYTHON_FLAMEGPU_TEMP_MODULE_PY}
  COMMAND ${CMAKE_COMMAND} -E copy_if_different ${PYTHON_FLAMEGPU_TEMP_MODULE_PY} ${PYTHON_FLAMEGPU_LIB_OUTPUT_MODULE_PY}
  COMMENT "Copying ${PYTHON_FLAMEGPU_TEMP_MODULE_PY} to ${PYTHON_FLAMEGPU_LIB_OUTPUT_MODULE_PY}"
)
list(APPEND PYTHON_MODULE_TARGET_NAME_DEPENDS "${PYTHON_FLAMEGPU_LIB_OUTPUT_MODULE_PY}")
unset(PYTHON_FLAMEGPU_TEMP_MODULE_PY)
unset(PYTHON_FLAMEGPU_LIB_OUTPUT_MODULE_PY)

list(APPEND PYTHON_MODULE_TARGET_NAME_SOURCES "${CMAKE_CURRENT_SOURCE_DIR}/setup.py.in")
list(APPEND PYTHON_MODULE_TARGET_NAME_SOURCES "${CMAKE_CURRENT_SOURCE_DIR}/__init__.py.in")
foreach(PYTHON_CODEGEN_FILE IN LISTS PYTHON_CODEGEN_SRC_FILES)
  list(APPEND PYTHON_MODULE_TARGET_NAME_SOURCES ${PYTHON_CODEGEN_FILE})
endforeach()

# Define a custom target, with the name intended to be invoked by users (i.e. pyflamegpu)
# This copies the generated .pyd/.so file produces by swig into the appropriate directory, and byuilds the wheel.
# Ideally the .pyd/so copy would be a custom_command which specifies the OUTPUT, but this is not possible due to TARGET genex's not being available for use in OUTPUTS or BYPRODUCTS, which is unlikely to be fixed in CMake.
add_custom_target(${PYTHON_MODULE_TARGET_NAME}
  ALL
  # Copy the python .pyd/.so file to the working dir
  COMMAND ${CMAKE_COMMAND} -E copy $<TARGET_FILE:${PYTHON_SWIG_TARGET_NAME}> src/${PYTHON_MODULE_NAME}/$<TARGET_FILE_NAME:${PYTHON_SWIG_TARGET_NAME}>
  # Build the wheel in the working dir
  COMMAND ${Python3_EXECUTABLE} -m build --wheel 
  WORKING_DIRECTORY ${PYTHON_LIB_OUTPUT_DIRECTORY}
  BYPRODUCTS
    ${PYTHON_LIB_OUTPUT_DIRECTORY}/src/${PYTHON_MODULE_NAME}
    ${PYTHON_LIB_OUTPUT_DIRECTORY}/src/build
    ${PYTHON_LIB_OUTPUT_DIRECTORY}/src/dist
    ${PYTHON_LIB_OUTPUT_DIRECTORY}/src/${PYTHON_MODULE_NAME}.egg-info
    ${PYTHON_LIB_OUTPUT_DIRECTORY}/src/setup.py
  DEPENDS ${PYTHON_MODULE_TARGET_NAME_DEPENDS}
  SOURCES ${PYTHON_MODULE_TARGET_NAME_SOURCES}
  COMMENT "Copying ${PYTHON_MODULE_NAME}.pyd/.so and Building ${PYTHON_MODULE_NAME} Wheel"
)

# Ensure the custom target depends on the swig wrapper target
add_dependencies(${PYTHON_MODULE_TARGET_NAME} ${PYTHON_SWIG_TARGET_NAME})

# Build Virtual Environment for python testing and install the packaged wheel
if(FLAMEGPU_BUILD_PYTHON_VENV)
	# Look for python module venv, error if not found
	flamegpu_search_python_module(venv)
	# Testing using a virtual environment
	set(VENV_EXECUTABLE ${Python3_EXECUTABLE} -m venv)
	set(VENV_DIR ${PYTHON_LIB_OUTPUT_DIRECTORY}/venv)
  set(VENV_BYPRODUCTS "${VENV_DIR}")
	if(WIN32)
		set(VENV_PIP "${VENV_DIR}\\Scripts\\pip.exe")
	else()
		set(VENV_PIP ${VENV_DIR}/bin/pip)
	endif()
	# make a venv to install our python package in it
	add_custom_command(TARGET ${PYTHON_MODULE_TARGET_NAME} POST_BUILD
		# create venv
    COMMAND ${VENV_EXECUTABLE} ${VENV_DIR}
    # Install the wheel from the dist dir. Specify a version incase the same build dir has been used for a previous build
    # Relaxed the no-index option to allow setup.py to install requirements
    COMMAND ${VENV_PIP} install --force-reinstall --find-links=dist -U ${PYTHON_DISTRIBUTION_NAME}==${FLAMEGPU_VERSION_PYTHON}
    # install pytest and astpretty 
    COMMAND ${VENV_PIP} install pytest astpretty
    BYPRODUCTS ${VENV_BYPRODUCTS}
    WORKING_DIRECTORY ${PYTHON_LIB_OUTPUT_DIRECTORY}
    COMMENT "Install ${PYTHON_DISTRIBUTION_NAME} ${FLAMEGPU_VERSION_PYTHON} wheel into ${VENV_DIR}"
  )
endif()

# set project folders (for better organisation in visual studio)
if (CMAKE_USE_FOLDERS)
  set_property(GLOBAL PROPERTY USE_FOLDERS ON)
  set_property(TARGET "${PYTHON_SWIG_TARGET_NAME}" PROPERTY FOLDER "FLAMEGPU")
  set_property(TARGET "${PYTHON_MODULE_TARGET_NAME}" PROPERTY FOLDER "FLAMEGPU")
endif ()

# Specify visual studio and eclpse source_group filters as required.
source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} PREFIX ${PYTHON_MODULE_TARGET_NAME} FILES ${PYTHON_MODULE_TARGET_NAME_SOURCES})
